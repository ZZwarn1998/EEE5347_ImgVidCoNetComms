# 3 Arithmetic coding

## 3.1 算法流程

1. 将当前间隔$[L,H)$初始化为$[0,1)$;  
2. 对于文件中的所有符号：
   - 我们将当前区间细分为子区间，每个子区间对应每个可能的字母符号。 根据输入模型，符号子区间的大小与该符号将成为文件中下一个符号的估计概率成正比。
   - 我们选择文件中下一个实际出现的符号对应的子区间，并使其成为新的当前区间。
3. 我们输出足够的位来区分最终的当前间隔和所有其他可能的最终间隔。  
&emsp;以下是关于symbol的可能性的表格。  
| symbol | probability |
| :----: | :---------: |
|   a    |     0.4     |
|   b    |     0.5     |
|  **EOF**   |     0.1     |
&emsp;假设我们有符号串序列```bbbEOF```，接下来我们利用Arithmetic coding的方法来为其设计对应的二进制序列。

<center><img src=".\image\subdivide.png"></cenetr>  

&emsp;最后，我们获得一个范围```[0.812.0.825)```，根据上图，我们可以明白计算过程是这样的  

<center>$$L_1=0+0.4\times(1-0)=0.4,H_1=0+0.9\times(1-0)=0.9$$</center>

<center>$$L_2=0.4+0.4\times(0.9-0.4)=0.6,H_2=0.4+0.9\times(0.9-0.4)=0.85$$</center>  

<center>$$L_3=0.6+0.4\times(0.85-0.6)=0.7,H_3=0.6+0.9\times(0.85-0.6)=0.825$$</center>  

<center>$$L_4=0.7+0.9\times(0.825-0.7)=0.8125,H_2=0.7+1\times(0.825-0.7)=0.825$$</center>   

&emsp;接着，我们需要做的就是在```[0.812,0.825)```里选择一个数，然后将其转化为二进制序列。在这里，我们选择0.8125，并将其转化为二进制字符串```0.1101000000...```，过程如下。

<center><img src="image\toBinary.png" height="50%" width="50%"></center>
&emsp;最后，代码比特长度为$-log_2{(0.5^3\times0.1)}=6.332$，事实上我们需要输出7bits。截取7位，我们可以获得唯一识别这个符号序列的二进制字符串```1101000```。

&emsp;关于复原，我们可以这样做。

<center><img src=".\image\decode.jpg" height ="50%" width="70%"></center>

&emsp;其实，就是不断寻找包含数值```0.8125```的区间。

